{"ast":null,"code":"import pieces, { pieceTypes } from \"./pieces\";\nimport decodeFEN from \"./FENtoBoard\";\n\n// export const calculateLegalMoves = (FEN_str, color, depth = 0) => {\n//   const FEN =  decodeFEN(FEN_str);\n\n//   return [];\n//   const pieces = FEN.board\n//     .map((piece, index) => (piece & color ? index : null))\n//     .filter((piece) => piece !== null);\n//   const moves = pieces\n//     .map((index) => {\n//       return calculateLegalMovesForPiece(FEN, index, depth);\n//     })\n//     .reduce((acc, val) => acc.concat(val), []);\n\n//   return moves;\n// };\n\nconst calculateLegalMovesForPiece = (FEN, index, depth) => {\n  let legalMoves;\n  const {\n    board,\n    turn,\n    castling,\n    enPassant,\n    halfMoveClock,\n    fullMoveNumber\n  } = decodeFEN(FEN);\n  const type = Object.keys(pieces).find(key => pieces[key] === board[index]);\n\n  // const type =\"p\";\n  //   switch (type.toLowerCase()) {\n  //     case \"p\":\n  //       legalMoves = calculatePawnMoves(board, index);\n  //       break;\n  //     case \"r\":\n  //       legalMoves = calculateRookMoves(board, index);\n  //       break;\n  //     case \"n\":\n  //       legalMoves = calculateKnightMoves(board, index);\n  //       break;\n  //     case \"b\":\n  //       legalMoves = calculateBishopMoves(board, index);\n  //       break;\n  //     case \"q\":\n  //       legalMoves = calculateQueenMoves(board, index);\n  //       break;\n  //     case \"k\":\n  //       if (depth) return calculateCandidateKingMoves(board, index);\n  //       else return calculateKingMoves(board, index);\n  //     default:\n  //       return [];\n  //   }\n  //   if (depth) return legalMoves;\n  //   const color =\n  //     board[index] & pieceTypes.White ? pieceTypes.White : pieceTypes.Black;\n  //   const kingIndex = board.indexOf(color | pieceTypes.King);\n  //   return legalMoves.filter((move) => {\n  //     return !isKingAttacked(movePiece(board, index, move), kingIndex, color);\n  //   });\n};\n\n// function calculatePawnMoves(board, index) {\n//   let rank = Math.floor(index / 8);\n//   let file = index % 8;\n//   const candidateMoves = [];\n//   if (board[index] & pieceTypes.White) {\n//     if (!isOccupied(board, index + 8)) candidateMoves.push(index + 8);\n//     if (\n//       rank === 1 &&\n//       !isOccupied(board, index + 16) &&\n//       !isOccupied(board, index + 8)\n//     )\n//       candidateMoves.push(index + 16);\n//     if (file > 0 && isOccupied(board, index + 7))\n//       candidateMoves.push(index + 7);\n//     if (file < 7 && isOccupied(board, index + 9))\n//       candidateMoves.push(index + 9);\n//   } else {\n//     if (!isOccupied(board, index - 8)) candidateMoves.push(index - 8);\n//     if (\n//       rank === 6 &&\n//       !isOccupied(board, index - 16) &&\n//       !isOccupied(board, index - 8)\n//     )\n//       candidateMoves.push(index - 16);\n//     if (file > 0 && isOccupied(board, index - 9))\n//       candidateMoves.push(index - 9);\n//     if (file < 7 && isOccupied(board, index - 7))\n//       candidateMoves.push(index - 7);\n//   }\n//   const legalMoves = candidateMoves.filter(\n//     (move) => !isSameColor(board, index, move)\n//   );\n\n//   return legalMoves;\n// }\n\n// function calculateRookMoves(board, index) {\n//   const candidateMoves = [];\n//   const rank = Math.floor(index / 8);\n//   const file = index % 8;\n//   for (let i = -1; i >= -file; i--) {\n//     if (isOccupied(board, index + i)) {\n//       candidateMoves.push(index + i);\n//       break;\n//     }\n//     candidateMoves.push(index + i);\n//   }\n//   for (let i = 1; i < 8 - file; i++) {\n//     if (isOccupied(board, index + i)) {\n//       candidateMoves.push(index + i);\n//       break;\n//     }\n//     candidateMoves.push(index + i);\n//   }\n//   for (let i = -1; i >= -rank; i--) {\n//     if (isOccupied(board, index + 8 * i)) {\n//       candidateMoves.push(index + 8 * i);\n//       break;\n//     }\n//     candidateMoves.push(index + 8 * i);\n//   }\n//   for (let i = 1; i < 8 - rank; i++) {\n//     if (isOccupied(board, index + 8 * i)) {\n//       candidateMoves.push(index + 8 * i);\n//       break;\n//     }\n//     candidateMoves.push(index + 8 * i);\n//   }\n//   const legalMoves = candidateMoves.filter(\n//     (move) => !isSameColor(board, index, move)\n//   );\n//   return legalMoves;\n// }\n\n// function calculateBishopMoves(board, index) {\n//   const candidateMoves = [];\n//   const rank = Math.floor(index / 8);\n//   const file = index % 8;\n//   // console.log(rank, file);\n//   for (let i = -1; i >= -Math.min(file, rank); i--) {\n//     //up and left\n//     candidateMoves.push(index + i + i * 8);\n//     if (isOccupied(board, index + i + i * 8)) break;\n//   }\n//   for (let i = 1; i < Math.min(8 - rank, 8 - file); i++) {\n//     //down and right\n//     candidateMoves.push(index + i + i * 8);\n//     if (isOccupied(board, index + i + i * 8)) break;\n//   }\n//   for (let i = -1; i >= 1 - Math.min(8 - file, 1 + rank); i--) {\n//     //up and right\n//     candidateMoves.push(index - i + i * 8);\n//     if (isOccupied(board, index - i + i * 8)) break;\n//   }\n//   for (let i = 1; i < Math.min(file, 8 - rank); i++) {\n//     //down and left\n//     candidateMoves.push(index - i + i * 8);\n//     if (isOccupied(board, index - i + i * 8)) break;\n//   }\n//   const legalMoves = candidateMoves.filter(\n//     (move) => !isSameColor(board, index, move)\n//   );\n//   console.log(legalMoves);\n//   return legalMoves;\n// }\n\n// function calculateKnightMoves(board, index) {\n//   let candidateMoves = [];\n//   const rank = Math.floor(index / 8);\n//   const file = index % 8;\n//   if (file > 0) {\n//     if (rank > 1) candidateMoves.push(index - 17);\n//     if (rank < 6) candidateMoves.push(index + 15);\n//   }\n//   if (file > 1) {\n//     if (rank > 0) candidateMoves.push(index - 10);\n//     if (rank < 7) candidateMoves.push(index + 6);\n//   }\n//   if (file < 6) {\n//     if (rank > 0) candidateMoves.push(index - 6);\n//     if (rank < 7) candidateMoves.push(index + 10);\n//   }\n//   if (file < 7) {\n//     if (rank > 1) candidateMoves.push(index - 15);\n//     if (rank < 6) candidateMoves.push(index + 17);\n//   }\n//   let legalMoves = candidateMoves.filter(\n//     (move) => !isSameColor(board, index, move)\n//   );\n//   return legalMoves;\n// }\n\n// function calculateQueenMoves(board, index) {\n//   return [\n//     ...calculateBishopMoves(board, index),\n//     ...calculateRookMoves(board, index),\n//   ];\n// }\n\n// function calculateCandidateKingMoves(board, index) {\n//   let candidateMoves = [];\n//   const rank = Math.floor(index / 8);\n//   const file = index % 8;\n//   if (file > 0) {\n//     candidateMoves.push(index - 1);\n//     if (rank > 0) candidateMoves.push(index - 9);\n//     if (rank < 7) candidateMoves.push(index + 7);\n//   }\n//   if (file < 7) {\n//     candidateMoves.push(index + 1);\n//     if (rank > 0) candidateMoves.push(index - 7);\n//     if (rank < 7) candidateMoves.push(index + 9);\n//   }\n//   if (rank > 0) candidateMoves.push(index - 8);\n//   if (rank < 7) candidateMoves.push(index + 8);\n\n//   return candidateMoves.filter((move) => !isSameColor(board, index, move));\n// }\n\n// export function calculateKingMoves(board, index) {\n//   const candidateMoves = calculateCandidateKingMoves(board, index);\n//   const white = board[index] & pieceTypes.White;\n//   const legalMoves = candidateMoves.filter((move) => {\n//     return !isKingAttacked(movePiece(board, index, move), move, white);\n//   });\n//   if (true && !isKingAttacked(board, index, white)) {\n//     //if king and rook haven't moved yet.\n//     if (white) {\n//       if (\n//         legalMoves.includes(5) &&\n//         !isKingAttacked(movePiece(board, index, 6), 6, white) &&\n//         board[6] === 0\n//       ) {\n//         legalMoves.push(6);\n//       }\n//       if (\n//         legalMoves.includes(3) &&\n//         board[2] === 0 &&\n//         !isKingAttacked(movePiece(board, index, 2), 2, white) &&\n//         board[1] === 0\n//       ) {\n//         legalMoves.push(2);\n//       }\n//     } else {\n//       if (\n//         legalMoves.includes(61) &&\n//         !isKingAttacked(movePiece(board, index, 62), 62, white) &&\n//         board[62] === 0\n//       ) {\n//         legalMoves.push(62);\n//       }\n//       if (\n//         legalMoves.includes(59) &&\n//         board[58] === 0 &&\n//         !isKingAttacked(movePiece(board, index, 58), 58, white) &&\n//         board[57] === 0\n//       ) {\n//         legalMoves.push(58);\n//       }\n//     }\n//   }\n//   return legalMoves;\n// }\n\nexport default calculateLegalMovesForPiece;\n\n// // UTILS\n\n// function isOccupied(board, index) {\n//   return board[index] !== 0;\n// }\n\n// function isSameColor(board, index1, index2) {\n//   return (\n//     board[index1] & board[index2] & pieceTypes.White ||\n//     board[index1] & board[index2] & pieceTypes.Black\n//   );\n// }\n\n// function movePiece(board, index, move) {\n//   const newBoard = [...board];\n//   newBoard[move] = newBoard[index];\n//   newBoard[index] = 0;\n//   return newBoard;\n// }\n\n// function isKingAttacked(board, index, color) {\n//   const opponentColor =\n//     color & pieceTypes.White ? pieceTypes.Black : pieceTypes.White;\n//   const opponentMoves = calculateLegalMoves(board, opponentColor, 1);\n//   return opponentMoves.includes(index);\n// }","map":{"version":3,"names":["pieces","pieceTypes","decodeFEN","calculateLegalMovesForPiece","FEN","index","depth","legalMoves","board","turn","castling","enPassant","halfMoveClock","fullMoveNumber","type","Object","keys","find","key"],"sources":["C:/Users/shane/Documents/Projects/chess-trainer/src/calculateMoves.js"],"sourcesContent":["import pieces, { pieceTypes } from \"./pieces\";\r\nimport decodeFEN from \"./FENtoBoard\";\r\n\r\n// export const calculateLegalMoves = (FEN_str, color, depth = 0) => {\r\n//   const FEN =  decodeFEN(FEN_str);\r\n\r\n//   return [];\r\n//   const pieces = FEN.board\r\n//     .map((piece, index) => (piece & color ? index : null))\r\n//     .filter((piece) => piece !== null);\r\n//   const moves = pieces\r\n//     .map((index) => {\r\n//       return calculateLegalMovesForPiece(FEN, index, depth);\r\n//     })\r\n//     .reduce((acc, val) => acc.concat(val), []);\r\n\r\n//   return moves;\r\n// };\r\n\r\nconst calculateLegalMovesForPiece = (FEN, index, depth) => {\r\n  let legalMoves;\r\n  const { board, turn, castling, enPassant, halfMoveClock, fullMoveNumber } = decodeFEN(FEN);\r\n  const type = Object.keys(pieces).find((key) => pieces[key] === board[index]);\r\n\r\n// const type =\"p\";\r\n//   switch (type.toLowerCase()) {\r\n//     case \"p\":\r\n//       legalMoves = calculatePawnMoves(board, index);\r\n//       break;\r\n//     case \"r\":\r\n//       legalMoves = calculateRookMoves(board, index);\r\n//       break;\r\n//     case \"n\":\r\n//       legalMoves = calculateKnightMoves(board, index);\r\n//       break;\r\n//     case \"b\":\r\n//       legalMoves = calculateBishopMoves(board, index);\r\n//       break;\r\n//     case \"q\":\r\n//       legalMoves = calculateQueenMoves(board, index);\r\n//       break;\r\n//     case \"k\":\r\n//       if (depth) return calculateCandidateKingMoves(board, index);\r\n//       else return calculateKingMoves(board, index);\r\n//     default:\r\n//       return [];\r\n//   }\r\n//   if (depth) return legalMoves;\r\n//   const color =\r\n//     board[index] & pieceTypes.White ? pieceTypes.White : pieceTypes.Black;\r\n//   const kingIndex = board.indexOf(color | pieceTypes.King);\r\n//   return legalMoves.filter((move) => {\r\n//     return !isKingAttacked(movePiece(board, index, move), kingIndex, color);\r\n//   });\r\n};\r\n\r\n// function calculatePawnMoves(board, index) {\r\n//   let rank = Math.floor(index / 8);\r\n//   let file = index % 8;\r\n//   const candidateMoves = [];\r\n//   if (board[index] & pieceTypes.White) {\r\n//     if (!isOccupied(board, index + 8)) candidateMoves.push(index + 8);\r\n//     if (\r\n//       rank === 1 &&\r\n//       !isOccupied(board, index + 16) &&\r\n//       !isOccupied(board, index + 8)\r\n//     )\r\n//       candidateMoves.push(index + 16);\r\n//     if (file > 0 && isOccupied(board, index + 7))\r\n//       candidateMoves.push(index + 7);\r\n//     if (file < 7 && isOccupied(board, index + 9))\r\n//       candidateMoves.push(index + 9);\r\n//   } else {\r\n//     if (!isOccupied(board, index - 8)) candidateMoves.push(index - 8);\r\n//     if (\r\n//       rank === 6 &&\r\n//       !isOccupied(board, index - 16) &&\r\n//       !isOccupied(board, index - 8)\r\n//     )\r\n//       candidateMoves.push(index - 16);\r\n//     if (file > 0 && isOccupied(board, index - 9))\r\n//       candidateMoves.push(index - 9);\r\n//     if (file < 7 && isOccupied(board, index - 7))\r\n//       candidateMoves.push(index - 7);\r\n//   }\r\n//   const legalMoves = candidateMoves.filter(\r\n//     (move) => !isSameColor(board, index, move)\r\n//   );\r\n\r\n//   return legalMoves;\r\n// }\r\n\r\n// function calculateRookMoves(board, index) {\r\n//   const candidateMoves = [];\r\n//   const rank = Math.floor(index / 8);\r\n//   const file = index % 8;\r\n//   for (let i = -1; i >= -file; i--) {\r\n//     if (isOccupied(board, index + i)) {\r\n//       candidateMoves.push(index + i);\r\n//       break;\r\n//     }\r\n//     candidateMoves.push(index + i);\r\n//   }\r\n//   for (let i = 1; i < 8 - file; i++) {\r\n//     if (isOccupied(board, index + i)) {\r\n//       candidateMoves.push(index + i);\r\n//       break;\r\n//     }\r\n//     candidateMoves.push(index + i);\r\n//   }\r\n//   for (let i = -1; i >= -rank; i--) {\r\n//     if (isOccupied(board, index + 8 * i)) {\r\n//       candidateMoves.push(index + 8 * i);\r\n//       break;\r\n//     }\r\n//     candidateMoves.push(index + 8 * i);\r\n//   }\r\n//   for (let i = 1; i < 8 - rank; i++) {\r\n//     if (isOccupied(board, index + 8 * i)) {\r\n//       candidateMoves.push(index + 8 * i);\r\n//       break;\r\n//     }\r\n//     candidateMoves.push(index + 8 * i);\r\n//   }\r\n//   const legalMoves = candidateMoves.filter(\r\n//     (move) => !isSameColor(board, index, move)\r\n//   );\r\n//   return legalMoves;\r\n// }\r\n\r\n// function calculateBishopMoves(board, index) {\r\n//   const candidateMoves = [];\r\n//   const rank = Math.floor(index / 8);\r\n//   const file = index % 8;\r\n//   // console.log(rank, file);\r\n//   for (let i = -1; i >= -Math.min(file, rank); i--) {\r\n//     //up and left\r\n//     candidateMoves.push(index + i + i * 8);\r\n//     if (isOccupied(board, index + i + i * 8)) break;\r\n//   }\r\n//   for (let i = 1; i < Math.min(8 - rank, 8 - file); i++) {\r\n//     //down and right\r\n//     candidateMoves.push(index + i + i * 8);\r\n//     if (isOccupied(board, index + i + i * 8)) break;\r\n//   }\r\n//   for (let i = -1; i >= 1 - Math.min(8 - file, 1 + rank); i--) {\r\n//     //up and right\r\n//     candidateMoves.push(index - i + i * 8);\r\n//     if (isOccupied(board, index - i + i * 8)) break;\r\n//   }\r\n//   for (let i = 1; i < Math.min(file, 8 - rank); i++) {\r\n//     //down and left\r\n//     candidateMoves.push(index - i + i * 8);\r\n//     if (isOccupied(board, index - i + i * 8)) break;\r\n//   }\r\n//   const legalMoves = candidateMoves.filter(\r\n//     (move) => !isSameColor(board, index, move)\r\n//   );\r\n//   console.log(legalMoves);\r\n//   return legalMoves;\r\n// }\r\n\r\n// function calculateKnightMoves(board, index) {\r\n//   let candidateMoves = [];\r\n//   const rank = Math.floor(index / 8);\r\n//   const file = index % 8;\r\n//   if (file > 0) {\r\n//     if (rank > 1) candidateMoves.push(index - 17);\r\n//     if (rank < 6) candidateMoves.push(index + 15);\r\n//   }\r\n//   if (file > 1) {\r\n//     if (rank > 0) candidateMoves.push(index - 10);\r\n//     if (rank < 7) candidateMoves.push(index + 6);\r\n//   }\r\n//   if (file < 6) {\r\n//     if (rank > 0) candidateMoves.push(index - 6);\r\n//     if (rank < 7) candidateMoves.push(index + 10);\r\n//   }\r\n//   if (file < 7) {\r\n//     if (rank > 1) candidateMoves.push(index - 15);\r\n//     if (rank < 6) candidateMoves.push(index + 17);\r\n//   }\r\n//   let legalMoves = candidateMoves.filter(\r\n//     (move) => !isSameColor(board, index, move)\r\n//   );\r\n//   return legalMoves;\r\n// }\r\n\r\n// function calculateQueenMoves(board, index) {\r\n//   return [\r\n//     ...calculateBishopMoves(board, index),\r\n//     ...calculateRookMoves(board, index),\r\n//   ];\r\n// }\r\n\r\n// function calculateCandidateKingMoves(board, index) {\r\n//   let candidateMoves = [];\r\n//   const rank = Math.floor(index / 8);\r\n//   const file = index % 8;\r\n//   if (file > 0) {\r\n//     candidateMoves.push(index - 1);\r\n//     if (rank > 0) candidateMoves.push(index - 9);\r\n//     if (rank < 7) candidateMoves.push(index + 7);\r\n//   }\r\n//   if (file < 7) {\r\n//     candidateMoves.push(index + 1);\r\n//     if (rank > 0) candidateMoves.push(index - 7);\r\n//     if (rank < 7) candidateMoves.push(index + 9);\r\n//   }\r\n//   if (rank > 0) candidateMoves.push(index - 8);\r\n//   if (rank < 7) candidateMoves.push(index + 8);\r\n\r\n//   return candidateMoves.filter((move) => !isSameColor(board, index, move));\r\n// }\r\n\r\n// export function calculateKingMoves(board, index) {\r\n//   const candidateMoves = calculateCandidateKingMoves(board, index);\r\n//   const white = board[index] & pieceTypes.White;\r\n//   const legalMoves = candidateMoves.filter((move) => {\r\n//     return !isKingAttacked(movePiece(board, index, move), move, white);\r\n//   });\r\n//   if (true && !isKingAttacked(board, index, white)) {\r\n//     //if king and rook haven't moved yet.\r\n//     if (white) {\r\n//       if (\r\n//         legalMoves.includes(5) &&\r\n//         !isKingAttacked(movePiece(board, index, 6), 6, white) &&\r\n//         board[6] === 0\r\n//       ) {\r\n//         legalMoves.push(6);\r\n//       }\r\n//       if (\r\n//         legalMoves.includes(3) &&\r\n//         board[2] === 0 &&\r\n//         !isKingAttacked(movePiece(board, index, 2), 2, white) &&\r\n//         board[1] === 0\r\n//       ) {\r\n//         legalMoves.push(2);\r\n//       }\r\n//     } else {\r\n//       if (\r\n//         legalMoves.includes(61) &&\r\n//         !isKingAttacked(movePiece(board, index, 62), 62, white) &&\r\n//         board[62] === 0\r\n//       ) {\r\n//         legalMoves.push(62);\r\n//       }\r\n//       if (\r\n//         legalMoves.includes(59) &&\r\n//         board[58] === 0 &&\r\n//         !isKingAttacked(movePiece(board, index, 58), 58, white) &&\r\n//         board[57] === 0\r\n//       ) {\r\n//         legalMoves.push(58);\r\n//       }\r\n//     }\r\n//   }\r\n//   return legalMoves;\r\n// }\r\n\r\nexport default calculateLegalMovesForPiece;\r\n\r\n// // UTILS\r\n\r\n// function isOccupied(board, index) {\r\n//   return board[index] !== 0;\r\n// }\r\n\r\n// function isSameColor(board, index1, index2) {\r\n//   return (\r\n//     board[index1] & board[index2] & pieceTypes.White ||\r\n//     board[index1] & board[index2] & pieceTypes.Black\r\n//   );\r\n// }\r\n\r\n\r\n\r\n// function movePiece(board, index, move) {\r\n//   const newBoard = [...board];\r\n//   newBoard[move] = newBoard[index];\r\n//   newBoard[index] = 0;\r\n//   return newBoard;\r\n// }\r\n\r\n// function isKingAttacked(board, index, color) {\r\n//   const opponentColor =\r\n//     color & pieceTypes.White ? pieceTypes.Black : pieceTypes.White;\r\n//   const opponentMoves = calculateLegalMoves(board, opponentColor, 1);\r\n//   return opponentMoves.includes(index);\r\n// }\r\n"],"mappings":"AAAA,OAAOA,MAAM,IAAIC,UAAU,QAAQ,UAAU;AAC7C,OAAOC,SAAS,MAAM,cAAc;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,MAAMC,2BAA2B,GAAGA,CAACC,GAAG,EAAEC,KAAK,EAAEC,KAAK,KAAK;EACzD,IAAIC,UAAU;EACd,MAAM;IAAEC,KAAK;IAAEC,IAAI;IAAEC,QAAQ;IAAEC,SAAS;IAAEC,aAAa;IAAEC;EAAe,CAAC,GAAGX,SAAS,CAACE,GAAG,CAAC;EAC1F,MAAMU,IAAI,GAAGC,MAAM,CAACC,IAAI,CAAChB,MAAM,CAAC,CAACiB,IAAI,CAAEC,GAAG,IAAKlB,MAAM,CAACkB,GAAG,CAAC,KAAKV,KAAK,CAACH,KAAK,CAAC,CAAC;;EAE9E;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeF,2BAA2B;;AAE1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}