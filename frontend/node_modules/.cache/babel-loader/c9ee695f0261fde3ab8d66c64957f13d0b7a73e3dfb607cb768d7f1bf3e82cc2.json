{"ast":null,"code":"import calculateLegalMovesForPiece, { calculateLegalMoves, isKingAttacked } from \"./calculateMoves\";\nimport { pieceTypes } from \"./pieces\";\nconst isOccupied = (board, index) => board[index] !== 0;\nconst getColor = (board, index) => {\n  if (board[index] & pieceTypes.White) return pieceTypes.White;\n  if (board[index] & pieceTypes.Black) return pieceTypes.Black;else return 0;\n};\nconst getType = (board, index) => board[index] & 0b111;\nconst isSameColor = (board, from, to) => !(getColor(board, from) !== getColor(board, to));\nconst movePiece = (board, _ref) => {\n  let {\n    from,\n    to\n  } = _ref;\n  const newBoard = [...board];\n  newBoard[to] = newBoard[from];\n  newBoard[from] = 0;\n  return newBoard;\n};\nconst moveToAlgebraicChessNotation = (fen, from, to) => {\n  console.log(\"BOARD:\", fen.board);\n  const board = fen.board;\n  const type = getType(board, to);\n  const color = getColor(board, to);\n  const oppositeColor = color === pieceTypes.White ? pieceTypes.Black : pieceTypes.White;\n  const isCheck = isKingAttacked(movePiece(fen.board, {\n    from,\n    to\n  }), color);\n  const isCapture = isOccupied(board, to);\n  const squares = \"abcdefgh\";\n  const pieces = [\"\", \"N\", \"B\", \"R\", \"Q\", \"K\"];\n  return `${pieces[type - 1].toUpperCase()}${isCapture && type === 1 ? squares[to % 8] : \"\"}${isCapture ? \"x\" : \"\"}${squares[to % 8]}${Math.floor(to / 8) + 1}${isCheck ? \"+\" : \"\"}`;\n};\nconst algebraicChessNotationToMove = (fen, notation) => {\n  if (notation === \"O-O\") return {\n    from: fen.turn === pieceTypes.White ? 4 : 60,\n    to: fen.turn === pieceTypes.White ? 6 : 62\n  };\n  if (notation === \"O-O-O\") return {\n    from: fen.turn === pieceTypes.White ? 4 : 60,\n    to: fen.turn === pieceTypes.White ? 2 : 58\n  };\n\n  //regex in short algebraic chess notation\n  const regex = /^([NBRQK]?)([a-h]?)([1-8]?)(x?)([a-h][1-8])(=[NBRQK]?)?(\\+|#)?$/;\n  const matches = notation.match(regex);\n  if (!matches) return null;\n  const [, type, file, rank, capture, to, promotion] = matches;\n  const turn = fen.turn === \"b\" ? pieceTypes.White : pieceTypes.Black;\n  const candidatePieces = fen.board.map((piece, index) => {\n    if (getType(fen.board, index) === pieceTypes.Pawn && getColor(fen.board, index) === turn) return index;\n    if (getType(fen.board, index) === pieceTypes[type] && getColor(fen.board, index) === turn) return index;\n    return null;\n  }).filter(index => index !== null);\n  const index = to.charCodeAt(0) - 97 + (8 - parseInt(to[1])) * 8;\n\n  //find piece that can move to the square\n  const piece = candidatePieces.find(from => {\n    const moves = calculateLegalMovesForPiece(fen, from);\n    return moves.includes(index);\n  });\n  return {\n    from: piece,\n    to: index\n  };\n};\nfunction checkGameOver(fen) {\n  if (fen.fullMoveNumber === 0) return false;\n  const board = fen.board;\n  const turn = fen.turn;\n  const color = turn === \"w\" ? 0b1000 : 0b10000;\n  const king = color | pieceTypes.King;\n  const kingIndex = board.indexOf(king);\n  const legalKingMoves = calculateLegalMovesForPiece(fen, kingIndex);\n  // console.log(legalMoves, isKingAttacked(fen, kingIndex));\n  return legalKingMoves.length === 0 && isKingAttacked(fen, color) && calculateLegalMoves(fen, color).length === 0;\n}\nfunction fenToString(fen) {\n  let file = 0;\n  const boardString = fen.board.map((piece, index) => {\n    if (piece === 0) return;\n    const type = piece & 0b111;\n    const color = piece & 0b1000;\n    const pieceString = [\"P\", \"N\", \"B\", \"R\", \"Q\", \"K\"][type - 1];\n    if (color === 0b1000) return pieceString.toLowerCase();\n    return pieceString;\n  });\n  return boardString.join(\"\");\n}\nexport { isOccupied, getColor, getType, isSameColor, movePiece, moveToAlgebraicChessNotation, algebraicChessNotationToMove, checkGameOver, fenToString };","map":{"version":3,"names":["calculateLegalMovesForPiece","calculateLegalMoves","isKingAttacked","pieceTypes","isOccupied","board","index","getColor","White","Black","getType","isSameColor","from","to","movePiece","_ref","newBoard","moveToAlgebraicChessNotation","fen","console","log","type","color","oppositeColor","isCheck","isCapture","squares","pieces","toUpperCase","Math","floor","algebraicChessNotationToMove","notation","turn","regex","matches","match","file","rank","capture","promotion","candidatePieces","map","piece","Pawn","filter","charCodeAt","parseInt","find","moves","includes","checkGameOver","fullMoveNumber","king","King","kingIndex","indexOf","legalKingMoves","length","fenToString","boardString","pieceString","toLowerCase","join"],"sources":["C:/Users/shane/Documents/Projects/chess-trainer/src/utils.js"],"sourcesContent":["import calculateLegalMovesForPiece, { calculateLegalMoves, isKingAttacked } from \"./calculateMoves\";\r\nimport { pieceTypes } from \"./pieces\";\r\n\r\nconst isOccupied = (board, index) => board[index] !== 0;\r\n\r\nconst getColor = (board, index) => {\r\n  if (board[index] & pieceTypes.White) return pieceTypes.White;\r\n  if (board[index] & pieceTypes.Black) return pieceTypes.Black;\r\n  else return 0;\r\n};\r\n\r\nconst getType = (board, index) => board[index] & 0b111;\r\n\r\nconst isSameColor = (board, from, to) =>\r\n  !(getColor(board, from) !== getColor(board, to));\r\n\r\nconst movePiece = (board, { from, to }) => {\r\n  const newBoard = [...board];\r\n  newBoard[to] = newBoard[from];\r\n  newBoard[from] = 0;\r\n  return newBoard;\r\n};\r\n\r\nconst moveToAlgebraicChessNotation = (fen, from, to) => {\r\n  console.log(\"BOARD:\", fen.board)\r\n  const board = fen.board;\r\n  const type = getType(board, to);\r\n  const color = getColor(board, to);\r\n  const oppositeColor =\r\n    color === pieceTypes.White ? pieceTypes.Black : pieceTypes.White;\r\n  const isCheck = isKingAttacked(movePiece(fen.board, {from, to}), color);\r\n  const isCapture = isOccupied(board, to);\r\n  const squares = \"abcdefgh\";\r\n  const pieces = [\"\", \"N\", \"B\", \"R\", \"Q\", \"K\"];\r\n  return `${pieces[type - 1].toUpperCase()}${\r\n    isCapture && type === 1 ? squares[to % 8] : \"\"\r\n  }${isCapture ? \"x\" : \"\"}${squares[to % 8]}${Math.floor(to / 8) + 1}${\r\n    isCheck ? \"+\" : \"\"\r\n  }`;\r\n};\r\n\r\nconst algebraicChessNotationToMove = (fen, notation) => {\r\n  if (notation === \"O-O\")\r\n    return {\r\n      from: fen.turn === pieceTypes.White ? 4 : 60,\r\n      to: fen.turn === pieceTypes.White ? 6 : 62,\r\n    };\r\n  if (notation === \"O-O-O\")\r\n    return {\r\n      from: fen.turn === pieceTypes.White ? 4 : 60,\r\n      to: fen.turn === pieceTypes.White ? 2 : 58,\r\n    };\r\n\r\n  //regex in short algebraic chess notation\r\n  const regex =\r\n    /^([NBRQK]?)([a-h]?)([1-8]?)(x?)([a-h][1-8])(=[NBRQK]?)?(\\+|#)?$/;\r\n  const matches = notation.match(regex);\r\n  if (!matches) return null;\r\n  const [, type, file, rank, capture, to, promotion] = matches;\r\n  const turn = fen.turn === \"b\" ? pieceTypes.White : pieceTypes.Black;\r\n  const candidatePieces = fen.board\r\n    .map((piece, index) => {\r\n      if (\r\n        getType(fen.board, index) === pieceTypes.Pawn &&\r\n        getColor(fen.board, index) === turn\r\n      )\r\n        return index;\r\n      if (\r\n        getType(fen.board, index) === pieceTypes[type] &&\r\n        getColor(fen.board, index) === turn\r\n      )\r\n        return index;\r\n      return null;\r\n    })\r\n    .filter((index) => index !== null);\r\n  const index = to.charCodeAt(0) - 97 + (8 - parseInt(to[1])) * 8;\r\n\r\n\r\n\r\n  //find piece that can move to the square\r\n  const piece = candidatePieces.find((from) => {\r\n    const moves = calculateLegalMovesForPiece(fen, from);\r\n    return moves.includes(index);\r\n  });\r\n  \r\n  return {\r\n    from: piece,\r\n    to: index,\r\n  };\r\n};\r\n\r\n\r\n\r\nfunction checkGameOver(fen) {\r\n  if(fen.fullMoveNumber === 0) return false;\r\n  const board = fen.board;\r\n  const turn = fen.turn;\r\n  const color = turn === \"w\" ? 0b1000 : 0b10000;\r\n  const king = color | pieceTypes.King;\r\n  const kingIndex = board.indexOf(king);\r\n  const legalKingMoves = calculateLegalMovesForPiece(fen, kingIndex);\r\n  // console.log(legalMoves, isKingAttacked(fen, kingIndex));\r\n  return (\r\n    legalKingMoves.length === 0 &&\r\n    isKingAttacked(fen, color) &&\r\n    calculateLegalMoves(fen, color).length === 0\r\n  );\r\n}\r\n\r\nfunction fenToString(fen){\r\n  let file = 0;\r\n  const boardString = fen.board.map((piece, index) => {\r\n    if(piece === 0) return;\r\n    const type = piece & 0b111;\r\n    const color = piece & 0b1000;\r\n    const pieceString = [\"P\", \"N\", \"B\", \"R\", \"Q\", \"K\"][type-1];\r\n    if(color === 0b1000) return pieceString.toLowerCase();\r\n    return pieceString;\r\n  });\r\n  return boardString.join(\"\");\r\n}\r\n\r\nexport {\r\n  isOccupied,\r\n  getColor,\r\n  getType,\r\n  isSameColor,\r\n  movePiece,\r\n  moveToAlgebraicChessNotation,\r\n  algebraicChessNotationToMove,\r\n  checkGameOver,\r\n  fenToString\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}